# Configuration générique de Spring Boot...
debug=false

# H2 config start ------------
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console
spring.datasource.url=jdbc:h2:mem:tickettothemoon
spring.datasource.name = TTTM
# org.h2.tools.Server server = org.h2.tools.Server.createTcpServer().start();
spring.datasource.generate-unique-name=true
spring.datasource.username=vi
spring.datasource.password=
spring.datasource.sql-script-encoding=UTF-8
spring.datasource.driver-class-name=org.h2.Driver

# H2 config end ------------------------

# JPA config start ------------
# - DEV -----------------------
spring.jpa.show-sql=true
# show SQL queries
spring.jpa.properties.hibernate.format_sql=true
# format SQL queries
spring.jpa.database=h2
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect

# - ddl -----------------------
spring.jpa.hibernate.ddl-auto=update
# Here, spring.jpa.hibernate.ddl-auto can be none, update, create, or create-drop. 
# 	- none: The default for MySQL. No change is made to the database structure.
# 	- update: Hibernate changes the database according to the given entity structures.
# 	- create: Creates the database every time but does not drop it on close.
# 	- create-drop: Creates the database and drops it when SessionFactory closes.
# You must begin with either create or update, because you do not yet have the database structure. After the first run, you can switch it to update or none, according to program requirements. Use update when you want to make some change to the database structure.
# The default for H2 and other embedded databases is create-drop. For other databases, such as MySQL, the default is none.
# SECURITY : 	It is a good security practice to, after your database is in a production state, set this to none, revoke all privileges from the MySQL user connected to the Spring application, and give the MySQL user only SELECT, UPDATE, INSERT, and DELETE. You can read more about this at the end of this guide (https://spring.io/guides/gs/accessing-data-mysql/).

spring.jpa.open-in-view=true
spring.data.jpa.repositories.bootstrap-mode=deferred
# Hibernate will bootstrap in a separate thread while the rest of your application’s startup processing proceeds in parallel

# - Naming strategy -----------------------
# spring.jpa.hibernate.naming.physical-strategy=org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy
# Configuration du mapping par défaut pour Hibernate
# - ne fonctionne qu'avec hibernate
# - complètement optionnel.
# Mapping par défaut pour Spring...
# Voir https://thorben-janssen.com/naming-strategies-in-hibernate-5/
# Mapping des noms dans Hibernate (pas JPA)
# à partir de la classe java :
# -> un nom "logique", celui que l'on peut définir avec "@Column" ou "@Table"
# -> un nom "physique", dans un second temps, qui permet d'implémenter des conventions de nommage (par exemple, 
#    nom en majuscule, terminé par "_TABLE", etc...)
# - noms en minuscule, et "_" entre les mots.

# spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
# Avec cette stratégie, les tables et les champs ont le même nom en Java et en SQL (modulo la casse gérée par la BD)
# JPA config end ------------------------

# actuator config start ------------
management.endpoints.web.base-path=/manage/actuator
# On déplace les endpoints dans un sous-chemin
# DEV: pour le développement, on active tous les endpoints
management.endpoints.web.exposure.include=*
# configuration des endpoints
# management.server.port: 9001
# management.server.address: 127.0.0.1
# PROD: pour la production, on active que les endpoints nécessaires
# management.endpoints.web.exposure.include=health,info,metrics
# actuator config end ------------------------

# Logging config start ------------
logging.level.org.springframework=INFO
# Get the logs from Spring : values are Log Level: ERROR, WARN, INFO, DEBUG, or TRACE.
spring.output.ansi.enabled=ALWAYS
#  Color-coded Output
 # Logging config end ------------------------

# compression config start ------------
server.compression.enabled=true
server.compression.mime-types=application/json,text/css,application/javascript
server.compression.min-response-size=2048
# compression config end ------------------------


# modelMapper config start ------------
# https://www.baeldung.com/entity-to-and-from-dto-for-a-java-spring-application
modelMapper.getConfiguration()
  .setFieldMatchingEnabled(true)
  .setFieldAccessLevel(Configuration.AccessLevel.PRIVATE);

# modelMapper config end ------------------------