
# Configuration générique de Spring Boot...
debug=true

spring.datasource.driver-class-name=org.h2.Driver
# Base de donnée (h2, mais en fichier. Vous pouvez être amenés à changer son emplacement).
# spring.datasource.url=jdbc:h2:~/mabase

# Pour minimiser les problèmes d'installation, je vous propose 
# une base en mémoire (non persistante, pour le coup.)
# l'URL ci-dessous est l'URL par défaut...
#            spring.datasource.url=jdbc:h2:mem:
# Avec cette URL, la base est en mémoire, mais elle est nommée
# Ce qui permet de la consulter avec la console h2
spring.datasource.url=jdbc:h2:mem:demo

spring.datasource.username=vi
spring.datasource.password=

# Active la console h2 sur l'URL http://localhost:8080/h2-console
spring.h2.console.enabled=true
# Configuration JPA

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect

# Configuration du mapping par défaut pour Hibernate
# - ne fonctionne qu'avec hibernate
# - complètement optionnel.

# Mapping par défaut pour Spring...
# Voir https://thorben-janssen.com/naming-strategies-in-hibernate-5/
# Mapping des noms dans Hibernate (pas JPA)
# à partir de la classe java :
# -> un nom "logique", celui que l'on peut définir avec "@Column" ou "@Table"
# -> un nom "physique", dans un second temps, qui permet d'implémenter des conventions de nommage (par exemple, 
#    nom en majuscule, terminé par "_TABLE", etc...)
# - noms en minuscule, et "_" entre les mots.

# Configuration par défaut pour Spring Boot et Hibernate:
spring.jpa.hibernate.naming.physical-strategy=org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy

# Avec cette stratégie, les tables et les champs ont le même nom en Java et en SQL (modulo la casse gérée par la BD)
# spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl


